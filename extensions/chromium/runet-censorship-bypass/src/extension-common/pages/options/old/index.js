'use strict';

const START = Date.now();
{

  const enableButton = function enablebutton() {

    document.getElementById('apply-mods').disabled = false;

  };

  const onModChanged = function onModChanged(ev) {

    enableButton();

  };
  ['pac-mods', 'own-mods'].forEach((id) => {

    document.getElementById(id).onchange = onModChanged;

  });

}

chrome.runtime.getBackgroundPage( (backgroundPage) =>
  backgroundPage.apis.errorHandlers.installListenersOn(
    window, 'PUP', async() => {

      const getStatus = () => document.querySelector('#status');

      const setStatusTo = (msg) => {

        getStatus().innerHTML = msg || '–•–æ—Ä–æ—à–µ–≥–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –í–∞–º!';

      };

      const antiCensorRu = backgroundPage.apis.antiCensorRu;
      const errorHandlers = backgroundPage.apis.errorHandlers;

      // SET DATE

      const setDate = () => {

        let dateForUser = '–Ω–∏–∫–æ–≥–¥–∞';
        if( antiCensorRu.lastPacUpdateStamp ) {
          let diff = Date.now() - antiCensorRu.lastPacUpdateStamp;
          let units = '–º—Å';
          const gauges = [
            [1000, '—Å'],
            [60, '–º–∏–Ω'],
            [60, '—á'],
            [24, '–¥–Ω'],
            [7, ' –Ω–µ–¥–µ–ª—å'],
            [4, ' –º–µ—Å—è—Ü–µ–≤'],
          ];
          for(const g of gauges) {
            const diffy = Math.floor(diff / g[0]);
            if (!diffy)
              break;
            diff = diffy;
            units = g[1];
          }
          dateForUser = diff + units + ' –Ω–∞–∑–∞–¥';
        }

        const dateElement = document.querySelector('.update-date');
        dateElement.innerText = dateForUser + ' / ' +
          (antiCensorRu.pacUpdatePeriodInMinutes/60) + '—á';
        dateElement.title = new Date(antiCensorRu.lastPacUpdateStamp)
          .toLocaleString('ru-RU');

      };

      setDate();
      chrome.storage.onChanged.addListener(
        (changes) => changes.lastPacUpdateStamp.newValue && setDate()
      );

      // CLOSE BUTTON

      document.querySelector('.close-button').onclick = () => window.close();

      // RADIOS FOR PROVIDERS

      const currentProviderRadio = () => {

        const iddy = antiCensorRu.getCurrentPacProviderKey() || 'none';
        return document.getElementById(iddy);

      };
      const checkChosenProvider = () => {

        currentProviderRadio().checked = true;

      };

      const showErrors = (err, ...warns) => {

        const warning = warns
          .map(
            (w) => w && w.message || ''
          )
          .filter( (m) => m )
          .map( (m) => '‚úò ' + m )
          .join('<br/>');

        let message = '';
        if (err) {
          let wrapped = err.wrapped;
          message = err.message || '';

          while( wrapped ) {
            const deeperMsg = wrapped && wrapped.message;
            if (deeperMsg) {
              message = message + ' &gt; ' + deeperMsg;
            }
            wrapped = wrapped.wrapped;
          }
        }
        message = message.trim();
        if (warning) {
          message = message ? message + '<br/>' + warning : warning;
        }
        setStatusTo(
          `<span style="color:red">
            ${err ? '<span class="emoji">üî•</span> –û—à–∏–±–∫–∞!' : '–ù–µ–∫—Ä–∏—Ç–∏—á–Ω–∞—è –æ—à–∏–±–∫–∞.'}
          </span>
          <br/>
          <span style="font-size: 0.9em; color: darkred">${message}</span>
          ${err ? '<a href class="link-button">[–¢–µ—Ö–Ω.–¥–µ—Ç–∞–ª–∏]</a>' : ''}`
        );
        if (err) {
          getStatus().querySelector('.link-button').onclick = function() {

            errorHandlers.viewError('pup-ext-err', err);
            return false;

          };
        }

      };

      const switchInputs = function(val) {

        const inputs = document.querySelectorAll('input');
        for ( let i = 0; i < inputs.length; i++ ) {
          const input = inputs[i];
          if (val === 'off') {
            input.dataset.previousDisabledValue = input.disabled;
            input.disabled = true;
          } else {
            input.disabled = input.dataset.previousDisabledValue === 'true';
          }
        }

      };

      const conduct = (beforeStatus, operation, afterStatus, onSuccess = () => {}, onError = () => {}) => {

        setStatusTo(beforeStatus);
        switchInputs('off');
        operation((err, res, ...warns) => {

          warns = warns.filter( (w) => w );
          if (err || warns.length) {
            showErrors(err, ...warns);
          } else {
            setStatusTo(afterStatus);
          }
          switchInputs('on');
          if (!err) {
            onSuccess(res);
          } else {
            onError(err);
          }
        });

      };

      const infoIcon = `<svg class="icon" style="position: relative; top: 0.08em">
        <use xlink:href="#icon-info"></use>
      </svg>`;

      const infoSign = function infoSign(tooltip) {

        return `<div class="desc">
          ${infoIcon}
          <div class="tooltip">${tooltip}</div>
        </div>`;

      };

      const infoUrl = (url) => `<a href="${url}" class="right-bottom-icon info-url">${infoIcon}</a>`;

      const camelToDash = (name) => name.replace(/([A-Z])/g, (_, p1) => '-' + p1.toLowerCase());
      // const dashToCamel = (name) => name.replace(/-(.)/g, (_, p1) => p1.toUpperCase());

      const appendInfoRow = (mountEl, conf, inputTypeAndName,
        {
          idPrefix = 'mods-',
          ifDashify = true,
          htmlAfterLabel = ''
        } = {}) => {

        mountEl.classList.add('info-row', 'hor-flex');
        if (conf.ifDisabled) {
          mountEl.title = '–í –†–ê–ó–†–ê–ë–û–¢–ö–ï!';
        }
        const iddy = idPrefix + ( ifDashify ? camelToDash(conf.key) : conf.key );
        mountEl.innerHTML = `
          <input ${inputTypeAndName} id=${iddy} ${conf.ifDisabled ? 'disabled' : ''}>
          <div class="label-container">
            <label for="${iddy}">${conf.label}</label>
            ${htmlAfterLabel}
          </div>` + (conf.desc ? infoSign(conf.desc) : infoUrl(conf.url));

      };

      { // PAC-PROVIDERS starts.

        const ul = document.getElementById('list-of-providers');
        const _firstChildOrNull = ul.firstChild;
        for(
          const provConf of antiCensorRu.getSortedEntriesForProviders()
        ) {
          const li = document.createElement('li');
          appendInfoRow(li, provConf, 'type="radio" name="pacProvider"',
            { idPrefix: '',
              ifDashify: false,
              htmlAfterLabel: `
                &nbsp;<a href class="link-button update-button"
                  id="update-${provConf.key}">[–æ–±–Ω–æ–≤–∏—Ç—å]</a>`
            }
          );
          li.querySelector('.link-button').onclick =
            () => {
              conduct(
                '–û–±–Ω–æ–≤–ª—è–µ–º...', (cb) => antiCensorRu.syncWithPacProviderAsync(cb),
                '–û–±–Ω–æ–≤–ª–µ–Ω–æ.'
              );
              return false;
            };
          ul.insertBefore( li, _firstChildOrNull );
        }
        checkChosenProvider();

        const radioClickHandler = function radioClickHandler(event) {

          const pacKey = event.target.id;
          if (
            pacKey === (
              antiCensorRu.getCurrentPacProviderKey() || 'none'
            )
          ) {
            return false;
          }
          if (pacKey === 'none') {
            conduct(
              '–û—Ç–∫–ª—é—á–µ–Ω–∏–µ...',
              (cb) => antiCensorRu.clearPacAsync(cb),
              '–û—Ç–∫–ª—é—á–µ–Ω–æ.',
              checkChosenProvider
            );
          } else {
            conduct(
              '–£—Å—Ç–∞–Ω–æ–≤–∫–∞...',
              (cb) => antiCensorRu.installPacAsync(pacKey, cb),
              'PAC-—Å–∫—Ä–∏–ø—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.',
              checkChosenProvider
            );
          }
          return false;

        };

        document.querySelectorAll('input[name=pacProvider]').forEach((radio) => {

          radio.onclick = radioClickHandler;

        });

      } // PAC-PROVIDERS ends.

      // IF MINI

      if (backgroundPage.apis.version.ifMini) {
        document.documentElement.classList.add('if-version-mini');
      }

      // IF INSIDE OPTIONS TAB

      const currentTab = await new Promise(
        (resolve) => chrome.tabs.query(
          {active: true, currentWindow: true},
          ([tab]) => resolve(tab)
        )
      );

      const ifInsideOptions = !currentTab || currentTab.url.startsWith('chrome://extensions/?options=');
      if (ifInsideOptions) {
        document.documentElement.classList.add('if-options-page');
      }


      { // KITCHEN PANELS starts.

        const pacKitchen = backgroundPage.apis.pacKitchen;
        const modKeyToLi = {};

        const applyMods = function applyMods(newMods) {

          conduct(
            '–ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏...',
            (cb) => pacKitchen.keepCookedNowAsync(newMods, cb),
            '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã.',
            () => {

              document.getElementById('apply-mods').disabled = true;

            }
          );

        };

        { // EXCEPTIONS TAB starts.

          { // EXC-MODS starts.

            const emodsList = document.getElementById('exc-mods');
            const _firstChildOrNull = emodsList.firstChild;

            for(const conf of pacKitchen.getOrderedConfigs('exceptions')) {

              const li = document.createElement('li');
              appendInfoRow(li, conf, `type="checkbox" ${conf.value ? 'checked' : ''}`);
              emodsList.insertBefore( li, _firstChildOrNull );

              const key = conf.key;
              modKeyToLi[key] = li;
              li.querySelector('input').onclick = function() {

                const oldMods = pacKitchen.getPacMods();
                oldMods[key] =  this.checked;
                applyMods(oldMods);

              };

            };

          }// EXC-MODS ends.

          { // EXC-EDITOR starts.

            const excEditor = document.getElementById('exc-editor');

            const validateHost = function validateHost(host) {

              const ValidHostnameRegex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;
              if(!ValidHostnameRegex.test(host)) {
                showErrors(new TypeError('–î–æ–ª–∂–Ω–æ –±—ã—Ç—å —Ç–æ–ª—å–∫–æ –¥–æ–º–µ–Ω–Ω–æ–µ –∏–º—è, –±–µ–∑ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞, –ø–æ—Ä—Ç–∞ –∏ –ø—É—Ç–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.'));
                return false;
              }
              return true;

            };

            const labelIfProxied = '‚úî';
            const labelIfNotProxied = '‚úò';
            const labelIfAuto = '‚Üª';

            const addOption = function addOption(host, yesNoUndefined) {

              const opt = document.createElement('option');
              // `value` may be changed for hiding line in the tooltip.
              opt.value = host;
              opt.dataset.host = host;
              switch(yesNoUndefined) {
                case true:
                  opt.label = labelIfProxied;
                  break;
                case false:
                  opt.label = labelIfNotProxied;
                  break;
                default:
                  opt.label = labelIfAuto;
              }
              const editorHost = excEditor.value.trim();
              if (host === editorHost) {
                excList.insertBefore( opt, excList.firstChild );
              } else {
                excList.appendChild(opt);
              }
              return opt;

            };

            const thisYes = document.getElementById('this-yes');
            const thisNo = document.getElementById('this-no');
            const thisAuto = document.getElementById('this-auto');
            const yesClass = 'if-yes';
            const noClass = 'if-no';

            function moveCursorIfNeeded() {

              const nu = excEditor.dataset.moveCursorTo;
              if(nu !== undefined) {
                excEditor.setSelectionRange(nu, nu);
                delete excEditor.dataset.moveCursorTo;
              }

            }

            const hideOpt = (opt) => opt.value = '\n';
            const unhideOptAndAddSpace = (opt) => opt.value = opt.dataset.host + ' ';

            const excList = document.getElementById('exc-list');

            excEditor.onkeydown = function(event) {

              moveCursorIfNeeded();
              if(event.key === 'Enter') {
                // Hide all.
                excList.childNodes.forEach( hideOpt );
              }
              return true;

            };

            const renderExceptionsPanelFromExcList = function renderExceptionsPanelFromExcList(event) {

              // If triangle button on right of datalist input clicked.

              let ifTriangleClicked = false;
              const ifClick = event && event.type === 'click';

              {
                const maxIndentFromRightInPx = 15;
                ifTriangleClicked = ifClick
                  && !excEditor.selectionStart && !excEditor.selectionEnd
                  && event.x > excEditor.getBoundingClientRect().right - maxIndentFromRightInPx;
              }

              const setInputValue = (newValue) => {

                if (ifClick && !ifTriangleClicked) {
                  // Don't jerk cursor on simple clicks.
                  return;
                }
                // See bug in my comment to http://stackoverflow.com/a/32394157/521957
                // First click on empty input may be still ignored.
                const nu = excEditor.selectionStart + newValue.length - excEditor.value.length;
                excEditor.value = newValue;
                excEditor.dataset.moveCursorTo = nu;
                window.setTimeout(moveCursorIfNeeded, 0);

              };

              const originalHost = excEditor.value.trim();
              const ifInit = !event;
              const currentHost = ifTriangleClicked ? '' : (originalHost || (ifInit ? '' : ' '));
              setInputValue(currentHost);

              let exactOpt = false;
              let editedOpt = false;
              excList.childNodes.forEach(
                (opt) => {

                  unhideOptAndAddSpace(opt);

                  if(opt.label === labelIfAuto) {
                    editedOpt = opt;
                    return;
                  }
                  if (opt.dataset.host === originalHost) {
                    exactOpt = opt;
                  }

                }
              );

              thisAuto.checked = true;
              excEditor.parentNode.classList.remove(noClass, yesClass);

              const ifInputEmpty = !originalHost;
              if (ifTriangleClicked || ifInputEmpty) {
                // Show all opts.
                if (editedOpt) {
                  // Example of editedOpt.value: 'abcde ' <- Mind the space (see unhideOptAndAddSpace)!
                  const ifBackspacedOneChar = ifInputEmpty && editedOpt.value.length < 3;
                  if (ifBackspacedOneChar) {
                    editedOpt.remove();
                  }
                }
                return true;
              }

              if (editedOpt) {
                const ifEditedOptAlreadyExists = editedOpt.dataset.host === originalHost;
                if(ifEditedOptAlreadyExists) {
                  hideOpt(editedOpt);
                  return true;
                }
                // Not exact! Update!
                editedOpt.remove();
              }

              if (!exactOpt) {
                editedOpt = addOption(originalHost, undefined);
                if (!ifClick) {
                  // New value was typed -- don't show tooltip.
                  hideOpt(editedOpt);
                }
                return true;
              }

              // Exact found!
              excList.childNodes.forEach(hideOpt);
              if(exactOpt.label === labelIfProxied) {
                thisYes.checked = true;
                excEditor.parentNode.classList.add(yesClass);
              } else {
                thisNo.checked = true;
                excEditor.parentNode.classList.add(noClass);
              }
              return true;

            };

            excEditor.onclick = excEditor.oninput = renderExceptionsPanelFromExcList;

            if (currentTab && !currentTab.url.startsWith('chrome')) {
              excEditor.value = new URL(currentTab.url).hostname;
            } else {
              // Show placeholder.
              excEditor.value = '';
            }

            { // Populate selector.

              const pacMods = pacKitchen.getPacMods();
              for(const host of Object.keys(pacMods.exceptions || {}).sort()) {
                addOption(host, pacMods.exceptions[host]);
              }
              renderExceptionsPanelFromExcList(); // Colorize input.

            }

            document.getElementById('exc-radio').onclick = function(event) {

              /* ON CLICK */
              if(event.target.tagName !== 'INPUT') {
                // Only label on checkbox.
                return true;
              }

              const host = excEditor.value.trim();

              const pacMods = pacKitchen.getPacMods();
              pacMods.exceptions = pacMods.exceptions || {};

              let fixOptions;
              const curOptOrNull = excList.querySelector(`[data-host="${host}"]`);

              if (thisAuto.checked) {
                delete pacMods.exceptions[host];
                fixOptions = () => {
                  curOptOrNull && curOptOrNull.remove();
                }
              } else {
                // YES or NO checked.
                const ifYesClicked = thisYes.checked;
                if (!validateHost(host)) {
                  return false;
                }
                if (ifYesClicked && !pacMods.filteredCustomsString) {
                  showErrors( new TypeError(
                    '–ü—Ä–æ–∫—Å–∏—Ä–æ–≤–∞—Ç—å –°–í–û–ò —Å–∞–π—Ç—ã –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –°–í–û–ò–• –ø—Ä–æ–∫—Å–∏ (—Å–º. ¬´–ú–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã¬ª ). –ù–µ—Ç —Å–≤–æ–∏—Ö –ø—Ä–æ–∫—Å–∏, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â–∏—Ö –≤–∞—à–∏–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º.'
                  ));
                  return false;
                }
                //const ifNew = !(host in pacMods.exceptions);
                pacMods.exceptions[host] = ifYesClicked;
                  // Change label.
                fixOptions = () => {
                  if (curOptOrNull) {
                    curOptOrNull.label = ifYesClicked ? labelIfProxied : labelIfNotProxied;
                  } else {
                    addOption(host, ifYesClicked);
                  }
                };
              }

              conduct(
                '–ü—Ä–∏–º–µ–Ω—è–µ–º –∏—Å–∫–ª—é—á–µ–Ω–∏—è...',
                (cb) => pacKitchen.keepCookedNowAsync(pacMods, cb),
                '–ò—Å–∫–ª—é—á–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω—ã. –ù–µ –∑–∞–±—ã–≤–∞–π—Ç–µ –æ –∫—ç—à–µ!',
                () => {

                  fixOptions();
                  // Window may be closed before this line executes.
                  renderExceptionsPanelFromExcList();

                }
              );
              return false; // Don't check before operation is finished.

            };

          } // EXC-EDITOR ends.

        } // EXCEPTIONS TAB ends.

        { // PAC MODS TAB starts.

          const modsList = document.getElementById('pac-mods');
          const _firstChildOrNull = modsList.firstChild;

          for(const conf of pacKitchen.getOrderedConfigs('general')) {

            const li = document.createElement('li');
            appendInfoRow(li, conf, `type="checkbox" ${conf.value ? 'checked' : ''}`);
            modsList.insertBefore( li, _firstChildOrNull );
            modKeyToLi[conf.key] = li;

          };

        } // PAC MODS TAB ends.

        const customProxyStringKey = 'customProxyStringRaw';
        const uiRaw = 'ui-proxy-string-raw';

        { // OWN PROXIES TAB starts.

          const ownsList = document.getElementById('own-mods');
          const _firstChildOrNull = ownsList.firstChild;

          for(const conf of pacKitchen.getOrderedConfigs('ownProxies')) {

            const li = document.createElement('li');
            appendInfoRow(li, conf, `type="checkbox" ${conf.value ? 'checked' : ''}`);

            const key = conf.key;
            const ifMultiline = key === customProxyStringKey;
            if (ifMultiline) {
              li.style.flexWrap = 'wrap';
              li.innerHTML += `
                <textarea
                  spellcheck="false"
                  placeholder="SOCKS5 localhost:9050; # Tor Expert
SOCKS5 localhost:9150; # Tor Browser
HTTPS 11.22.33.44:3143;
PROXY foobar.com:8080; # Not HTTP!">${conf.value || localStorage.getItem(uiRaw) || ''}</textarea>
              `;
              li.querySelector('textarea').onkeyup = function() {

                this.dispatchEvent( new Event('change', {'bubbles': true}) );

              };
            }

            ownsList.insertBefore( li, _firstChildOrNull );
            modKeyToLi[key] = li;

          }

        } // OWN PROXIES TAB ends.

        { // APPLY MODS PANEL starts.

          document.getElementById('apply-mods').onclick = () => {

            const oldMods = pacKitchen.getPacMods();
            for(const key of Object.keys(modKeyToLi)) {
              oldMods[key] = modKeyToLi[key].querySelector('input').checked;
            };

            {
              // OWN PROXY

              const liPs = modKeyToLi[customProxyStringKey];
              oldMods[customProxyStringKey]
                = liPs.querySelector('input').checked
                  && liPs.querySelector('textarea').value.trim();

              const taVal = liPs.querySelector('textarea').value;
              if (oldMods[customProxyStringKey] !== false) {
                const ifValidArr = taVal
                  .trim()
                  .replace(/#.*$/mg, '')
                  .split(/\s*[;\n\r]+\s*/g)
                  .filter( (str) => str );
                const ifValid = ifValidArr.every(
                  (str) =>
                    /^(?:DIRECT|(?:(?:HTTPS|PROXY|SOCKS(?:4|5)?)\s+\S+))$/g
                      .test(str.trim())
                );
                if (!(ifValidArr.length && ifValid)) {
                  return showErrors(new TypeError(
                    '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å–≤–æ–∏—Ö –ø—Ä–æ–∫—Å–∏. –°–≤–µ—Ä—Ç–µ—Å—å —Å <a href="https://rebrand.ly/ac-own-proxy" data-in-bg="true">–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π</a>.'
                  ));
                }
                oldMods[customProxyStringKey] = taVal;
              } else {
                localStorage.setItem(uiRaw, taVal);
              }

            }
            applyMods(oldMods);

          };

          document.getElementById('reset-mods').onclick = () => {

            const ifSure = backgroundPage.confirm('–°–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –∏ –ò–°–ö–õ–Æ–ß–ï–ù–ò–Ø?');
            if (!ifSure) {
              return false;
            }
            conduct(
              '–°–±—Ä–∞—Å—ã–≤–∞–µ–º...',
              (cb) => {

                pacKitchen.resetToDefaults();
                backgroundPage.utils.fireRequest('ip-to-host-reset-to-defaults', cb);

              },
              '–û—Ç–∫—Ä–æ–π—Ç–µ –æ–∫–Ω–æ –∑–∞–Ω–æ–≤–æ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —ç—Ñ—Ñ–µ–∫—Ç–∞.',
              () => window.close()
            );

          }

        } // APPLY MODS PANEL ends.

      } // KITCHEN PANELS ends.

      // NOTIFICATIONS PANEL

      const conPanel = document.getElementById('list-of-notifiers');
      errorHandlers.getEventsMap().forEach( (value, name) => {

        const li = document.createElement('li');
        li.innerHTML = `
          <input type="checkbox" id="if-on-${name}"/>
          <label for="if-on-${name}">${value}</label>`;
        const box = li.querySelector('input');
        box.checked = backgroundPage.apis.errorHandlers.isOn(name);
        box.onclick = function() {

          const id = this.id.replace('if-on-', '');
          return backgroundPage.apis.errorHandlers.switch(
            this.checked ? 'on' : 'off',
            id
          );

        };
        conPanel.appendChild(li);

      });

      if( !errorHandlers.ifControllable ) {
        document.getElementById('which-extension').innerHTML
          = backgroundPage.utils.messages.whichExtensionHtml();
        document.querySelectorAll('.if-not-controlled').forEach( (node) => {

          node.style.display = 'block';

        });
      }
      setStatusTo('');

      if (antiCensorRu.ifFirstInstall) {
        const id = antiCensorRu.getCurrentPacProviderKey() || 'none';
        document.querySelector('#update-' + id).click();
      }
      document.documentElement.style.display = 'initial';

      console.log(Date.now() - START);

    })
);
